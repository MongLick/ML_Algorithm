using System;
using System.Collections.Generic;

namespace _01._List
{
	internal class Program
	{
		/*******************************************************
         * 리스트 (List)
         * 
         * 런타임 중 크기를 확장할 수 있는 배열기반의 자료구조
         * 배열요소의 갯수를 특정할 수 없는 경우 사용이 용이
         *******************************************************/

		// <리스트 구현>
		// 리스트는 배열기반의 자료구조이며, 배열은 크기를 변경할 수 없는 자료구조
		// 리스트는 동작 중 크기를 확장하기 위해 포함한 데이터보다 더욱 큰 배열을 사용
		//
		// 크기 = 3, 용량 = 8       크기 = 4, 용량 = 8       크기 = 5, 용량 = 8
		// ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐
		// │1│2│3│ │ │ │ │ │        │1│2│3│4│ │ │ │ │        │1│2│3│4│5│ │ │ │
		// └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘


		// <리스트 삽입>
		// 중간에 데이터를 추가하기 위해 이후 데이터들을 뒤로 밀어내고 삽입 진행
		//      ↓                        ↓                        ↓
		// ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐
		// │1│2│3│4│ │ │ │ │   =>   │1│2│ │3│4│ │ │ │   =>   │1│2│A│3│4│ │ │ │
		// └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘


		// <리스트 삭제>
		// 중간에 데이터를 삭제한 뒤 빈자리를 채우기 위해 이후 데이터들을 앞으로 당김
		//      ↓                        ↓
		// ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐
		// │1│2│A│3│4│ │ │ │   =>   │1│2│ │3│4│ │ │ │   =>   │1│2│3│4│ │ │ │ │
		// └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘


		// <리스트 용량>
		// 용량을 가득 채운 상황에서 데이터를 추가하는 경우
		// 더 큰 용량의 배열을 새로 생성한 뒤 데이터를 복사하여 새로운 배열을 사용
		//
		// 1. 리스트가 가득찬 상황에서 새로운 데이터 추가 시도
		// 크기 = 8, 용량 = 8
		// ┌─┬─┬─┬─┬─┬─┬─┬─┐
		// │1│2│3│4│5│6│7│8│ ← A 추가
		// └─┴─┴─┴─┴─┴─┴─┴─┘
		//
		// 2. 새로운 더 큰 배열 생성
		// 크기 = 8, 용량 = 8          크기 = 0, 용량 = 16
		// ┌─┬─┬─┬─┬─┬─┬─┬─┐           ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
		// │1│2│3│4│5│6│7│8│ ← A 추가  │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │
		// └─┴─┴─┴─┴─┴─┴─┴─┘           └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
		//
		// 3. 새로운 배열에 기존의 데이터 복사
		// 크기 = 8, 용량 = 8          크기 = 8, 용량 = 16
		// ┌─┬─┬─┬─┬─┬─┬─┬─┐           ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
		// │1│2│3│4│5│6│7│8│ ← A 추가  │1│2│3│4│5│6│7│8│ │ │ │ │ │ │ │ │
		// └─┴─┴─┴─┴─┴─┴─┴─┘           └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
		//
		// 4. 기본 배열 대신 새로운 배열을 사용
		// 크기 = 8, 용량 = 16
		// ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
		// │1│2│3│4│5│6│7│8│ │ │ │ │ │ │ │ │ ← A 추가
		// └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
		//
		// 5. 빈공간에 데이터 추가
		// 크기 = 9, 용량 = 16
		// ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
		// │1│2│3│4│5│6│7│8│A│ │ │ │ │ │ │ │
		// └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘


		// <리스트 시간복잡도>
		// 접근    탐색    삽입    삭제
		// O(1)    O(n)    O(n)    O(n)

		static void Main(string[] args)
		{
			List<string> list = new List<string>();
			List<int> list1 = new List<int>();
			list1.Capacity = 10000;                  // 만들 당시에 이 정도 쓸 것 같아하면 이렇게 하는게 좋다 왜? 4 8 16 32 이렇게 늘어나면서 4 8 16이 쓰레기가 되기 때문

			List<int> list12 = new List<int>(10000); // 혹은 이렇게 바로 쓸 수도 있다.

			// 삽입
			list.Add("0번 데이터");
			list.Add("1번 데이터");
			list.Add("2번 데이터");
			list.Insert(1, "중간 데이터1");
			list.Insert(3, "중간 데이터2");
			list.Insert(5, "끝");

			// 둘다 사용해도 사용해도 상관없을 때는 add가 더 좋음 왜? 인서트는 중간에 끼워넣어야해서 add는 그냥 뒤에 추가하면 되기 때문이다.

			// 삭제
			list.Remove("1번 데이터");
			list.RemoveAt(1);
			list.RemoveAt(list.Count -1);


			// 접근
			list[0] = "데이터0";
			string value = list[0];


			// 탐색
			int indexOf = list.IndexOf("2번 데이터");

			for(int i = 0; i < list.Count; i++)      // 리스트는 카운트로
			{
				list[i] = value;
			}
		}
	}
}